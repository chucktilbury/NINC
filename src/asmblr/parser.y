%debug
%defines
%locations

%{

#include "common.h"
#include "scanner.h"
#include "asmblr.h"

extern Assembler* asmblr;

%}

%union {
    char* str;
    char* symbol;
    double num;
    int type;
    bool bool_val;
    int opcode;
    int reg;

    /* These union objects are generated from boilerplate. */
};


%token<opcode> EXIT NOP CALL TRAP RETURN JMP BR PUSH POP PEEK SIDX LOAD
%token<opcode> STORE NOT EQ NEQ LTE GTE LT GT NEG ADD SUB MUL DIV MOD

%token<reg> R0 R1 R2 R3 R4 R5 R6 R7 R8
%token<reg> R9 R10 R11 R12 R13 R14 R15
%token CONST IMPORT

%token<bool_val> TRUE FALSE
%token<type> NUMBER STRING BOOLEAN NOTHING
%token<symbol> SYMBOL
%token<num> NUM
%token<str> QSTRG

%type<reg> register

    /* token list automatically generated by boilerplate */

%define parse.error verbose
%locations

%left '+' '-'
%left '*' '/' '%'
%left NEGATE

%%

module
    : module_list {}
    ;

module_item
    : data_definition {}
    | label_definition {}
    | instruction_definition {}
    | IMPORT QSTRG {}
    ;

module_list
    : module_item {}
    | module_list module_item {}
    ;

type_name
    : NUMBER {}
    | STRING {}
    | BOOLEAN {}
    ;

type_preamble
    : type_name {}
    | CONST type_name {}
    ;

data_definition
    : type_preamble SYMBOL {}
    | type_preamble SYMBOL '=' NUM {}
    | type_preamble SYMBOL '=' QSTRG {}
    | type_preamble SYMBOL '=' TRUE {}
    | type_preamble SYMBOL '=' FALSE {}
    ;

label_definition
    : SYMBOL ':' {}
    ;

instruction_definition
    : EXIT {}
    | RETURN {}
    | NOP {}
    /* One register operand */
    | NOT register {}
    | POP register {}
    | PUSH register {}
    | SIDX register {}
    /* Two register operands */
    | NEG register ',' register {}
    | EQ register ',' register {}
    | NEQ register ',' register {}
    | LTE register ',' register {}
    | GTE register ',' register {}
    | LT register ',' register {}
    | GT register ',' register {}
    | LOAD register ',' register {}
    /* Three register operands */
    | ADD register ',' register ',' register {}
    | SUB register ',' register ',' register {}
    | MUL register ',' register ',' register {}
    | DIV register ',' register ',' register {}
    | MOD register ',' register ',' register {}
    /* Trap instruction. Convert index to int. */
    | TRAP NUM {}
    /* Load the value of a var into a register */
    | LOAD register ',' SYMBOL {}
    /* Load a literal number into a register */
    | LOAD register ',' NUM {}
    /* Store the value of a register into a var */
    | STORE SYMBOL ',' register {}
    /* Flow control instructions accept the name of a label. */
    | CALL SYMBOL {}
    | JMP SYMBOL {}
    | BR SYMBOL {}
    /* Peek at the stack with a given register and index. */
    | PEEK register ',' register ',' NUM {}
    /* Push the value of the var onto the stack. */
    | PUSH SYMBOL {}
    /* Push a numeric literal onto the stack */
    | PUSH NUM {}
    /* Push a boolean onto the stack */
    | PUSH TRUE {}
    | PUSH FALSE {}
    ;

register
    : R0 { $$ = $1; }
    | R1 { $$ = $1; }
    | R2 { $$ = $1; }
    | R3 { $$ = $1; }
    | R4 { $$ = $1; }
    | R5 { $$ = $1; }
    | R6 { $$ = $1; }
    | R7 { $$ = $1; }
    | R8 { $$ = $1; }
    | R9 { $$ = $1; }
    | R10 { $$ = $1; }
    | R11 { $$ = $1; }
    | R12 { $$ = $1; }
    | R13 { $$ = $1; }
    | R14 { $$ = $1; }
    | R15 { $$ = $1; }
    ;

%%

void yyerror(const char* s) {

    fprintf(stderr, "%s:%d:%d %s\n", get_file_name(), get_line_no(), get_col_no(), s);
    //error("%s", s);
}

const char* tokenToStr(int tok) {

    return yysymbol_name(YYTRANSLATE(tok));
}
